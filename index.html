<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>3D Birthday • Three.js</title>
<style>
  html,body{height:100%;margin:0;background:#0b0b0b}
  #app{position:fixed;inset:0;z-index:0}
  canvas{display:block}
  .hud{position:fixed;top:14px;right:14px;display:flex;gap:10px;z-index:12}
  .btn{padding:12px 16px;background:rgba(255,255,255,.18);color:#fff;border:0;border-radius:12px;cursor:pointer;font:600 15px system-ui;backdrop-filter:blur(6px)}
  .start{position:fixed;inset:0;display:grid;place-items:center;z-index:9999;background:rgba(0,0,0,.72);color:#eee;pointer-events:auto}
  .panel{background:#111;border:1px solid #333;padding:22px;border-radius:14px;width:420px;text-align:center}
  .start .btn{background:#3a86ff}
</style>
</head>
<body>
  <div id="app"></div>

  <div class="hud">
    <button id="mute" class="btn">Unmute</button>
    <button id="play" class="btn">Play</button>
  </div>

  <div id="gate" class="start">
    <div class="panel">
      <div style="font-size:22px;margin-bottom:8px">Ready?</div>
      <div style="font-size:14px;opacity:.85;margin-bottom:16px">Tap Start to begin (audio optional).</div>
      <button id="start" class="btn">Start</button>
    </div>
  </div>

  <!-- Hidden YouTube container -->
  <div id="yt" style="position:fixed;width:0;height:0;overflow:hidden"></div>

  <!-- 0) BOOT: tiny non-module. Removes overlay & emits app-start ASAP -->
  <script>
    (function boot(){
      const gate = document.getElementById('gate');
      function start(){
        if (window.__started) return;
        window.__started = true;
        try { gate && gate.remove(); } catch {}
        document.dispatchEvent(new Event('app-start'));
      }
      // bind multiple events for reliability
      const s = document.getElementById('start');
      ['click','pointerdown','touchstart'].forEach(ev => s.addEventListener(ev, start, {passive:true}));
      // debug helper: show JS errors on screen instead of silently failing
      window.addEventListener('error', (e)=>{
        const div=document.createElement('div');
        div.style.cssText='position:fixed;bottom:10px;left:10px;background:#300;color:#fff;padding:10px;border-radius:8px;z-index:99999;font:12px monospace;max-width:90vw';
        div.textContent='JS error: '+(e.message||e.error||'unknown');
        document.body.appendChild(div);
      });
    })();
  </script>

  <!-- 1) MAIN MODULE: Three.js scene -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js';
    import { RoundedBoxGeometry } from 'https://unpkg.com/three@0.161.0/examples/jsm/geometries/RoundedBoxGeometry.js';

    // --- CONFIG (edit these only) ---
    const SKYLINE = 'https://upload.wikimedia.org/wikipedia/commons/d/d1/Toronto_Skyline_at_night_-b.jpg';
    const PHOTOS = ['p1.jpg','p2.jpg','p3.jpg','p4.jpg'];  // put files next to index.html
    const YT_ID = 'B-2BCSxnyHA';
    const YT_START = 84;

    // --- Renderer / scene / camera ---
    const app = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    renderer.setSize(innerWidth,innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 200);
    camera.position.set(3.8,2.6,5.4);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.target.set(0,0.45,0);

    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(innerWidth,innerHeight);
    });

    scene.add(new THREE.AmbientLight(0xffffff,0.62));
    const spot = new THREE.SpotLight(0xffffff,1.35,0,0.6,0.7,1.2); spot.position.set(4,6,2); spot.castShadow=true; scene.add(spot);

    // --- helpers ---
    const texFromCanvas = (draw,w=1024,h=1024)=>{
      const c=document.createElement('canvas'); c.width=w; c.height=h; const g=c.getContext('2d');
      draw(g,w,h); const t=new THREE.CanvasTexture(c); t.colorSpace=THREE.SRGBColorSpace; t.anisotropy=16; return t;
    };
    const loadTex = (url)=>new Promise(res=>{
      const t=new THREE.Texture(), img=new Image(); img.crossOrigin='anonymous';
      img.onload=()=>{ t.image=img; t.needsUpdate=true; t.colorSpace=THREE.SRGBColorSpace; t.anisotropy=16; res(t); };
      img.onerror=()=>res(texFromCanvas(g=>{ g.fillStyle='#bbb'; g.fillRect(0,0,1024,1024); }));
      img.src=url;
    });

    // --- table + cloth ---
    const wood = texFromCanvas((g,w,h)=>{ g.fillStyle='#6e4a2e'; g.fillRect(0,0,w,h); for(let y=0;y<h;y++){ const a=30+Math.sin(y*0.015)*18+Math.sin(y*0.06)*6; g.fillStyle=`rgba(255,255,255,${(a/255)*0.08})`; g.fillRect(0,y,w,1);} });
    wood.wrapS=wood.wrapT=THREE.RepeatWrapping; wood.repeat.set(2.2,2.2);
    const cloth = texFromCanvas((g,w,h)=>{ const A='#e7defa', B='#1c1c22', n=12, s=w/n; for(let y=0;y<n;y++)for(let x=0;x<n;x++){ g.fillStyle=((x+y)%2)?B:A; g.fillRect(x*s,y*s,s,s);} });
    cloth.wrapS=cloth.wrapT=THREE.RepeatWrapping; cloth.repeat.set(2.6,2.15);

    const tableTop = new THREE.Mesh(new THREE.BoxGeometry(14,0.18,10), new THREE.MeshPhysicalMaterial({ map:wood, metalness:.05, roughness:.38, clearcoat:.65, clearcoatRoughness:.25 }));
    tableTop.castShadow = tableTop.receiveShadow = true; scene.add(tableTop);
    const clothMesh = new THREE.Mesh(new THREE.PlaneGeometry(13.6,9.8), new THREE.MeshStandardMaterial({ map:cloth }));
    clothMesh.rotation.x=-Math.PI/2; clothMesh.position.y=0.1; clothMesh.receiveShadow=true; scene.add(clothMesh);

    // --- L-shaped skyline (3D, no floor gap) ---
    (async()=>{
      const sky = await loadTex(SKYLINE);
      const m = new THREE.MeshBasicMaterial({ map:sky, toneMapped:false });
      const W=28,H=W*9/16, y=0.1+H/2, d=5.0;
      const back = new THREE.Mesh(new THREE.BoxGeometry(W,H,0.1), m); back.position.set(0,y,-d-0.1); scene.add(back);
      const side = new THREE.Mesh(new THREE.BoxGeometry(W,H,0.1), m); side.position.set(7.1,y,0); side.rotation.y=-Math.PI/2; scene.add(side);
      const r=7.1;
      const corner = new THREE.Mesh(
        new THREE.CylinderGeometry(r,r,H,80,1,false,Math.PI,Math.PI/2),
        new THREE.MeshBasicMaterial({ map:sky, side:THREE.DoubleSide, toneMapped:false })
      ); corner.position.set(r,y,-r); corner.rotation.y=Math.PI/2; scene.add(corner);
    })();

    // --- frames ---
    async function addFrame(url, pos, rot){
      const group=new THREE.Group(); group.position.set(...pos); group.rotation.set(...rot);
      const W=1.5,H=1.05;
      const rim = new THREE.Mesh(new RoundedBoxGeometry(W+0.16,H+0.16,0.08,6,0.06), new THREE.MeshStandardMaterial({ color:'#b48a64', metalness:.15, roughness:.6 })); rim.position.y=H/2; rim.castShadow=true; group.add(rim);
      const mat = new THREE.Mesh(new THREE.BoxGeometry(W+0.04,H+0.04,0.02), new THREE.MeshStandardMaterial({ color:'#f3efe8'})); mat.position.y=H/2; mat.position.z=0.03; group.add(mat);
      const tex = await loadTex(url); const ph = new THREE.Mesh(new THREE.PlaneGeometry(W,H), new THREE.MeshBasicMaterial({ map:tex, toneMapped:false })); ph.position.y=H/2; ph.position.z=0.05; group.add(ph);
      const stand = new THREE.Mesh(new THREE.CylinderGeometry(0,0.18,0.25,4), new THREE.MeshStandardMaterial({ color:'#6e5a46', roughness:.95 })); stand.rotation.x=Math.PI/2; stand.position.set(0,0.02,-0.08); group.add(stand);
      scene.add(group);
    }
    addFrame(PHOTOS[0],[-2.2,0.09,0.1],[0,THREE.MathUtils.degToRad(20),0]);
    addFrame(PHOTOS[1],[-1.1,0.09,-1.35],[0,THREE.MathUtils.degToRad(42),0]);
    addFrame(PHOTOS[2],[1.25,0.09,-1.45],[0,THREE.MathUtils.degToRad(-38),0]);
    addFrame(PHOTOS[3],[2.35,0.09,0.15],[0,THREE.MathUtils.degToRad(-16),0]);

    // --- cake (colorful) ---
    const cake = new THREE.Group(); cake.position.set(0,0.5,0); scene.add(cake);
    const plate = new THREE.Mesh(new THREE.CircleGeometry(1.25,64), new THREE.MeshStandardMaterial({ color:'#f7f7f7', roughness:.35, metalness:.05 })); plate.rotation.x=-Math.PI/2; plate.position.y=-0.505; plate.receiveShadow=true; cake.add(plate);
    for(let i=0;i<24;i++){ const a=i/24*Math.PI*2, r=0.95; const p=new THREE.Mesh(new THREE.SphereGeometry(0.05,16,16), new THREE.MeshStandardMaterial({ color:'#fff7f5', roughness:.2 })); p.position.set(Math.cos(a)*r,0.18,Math.sin(a)*r); p.castShadow=true; cake.add(p); }
    const lower = new THREE.Mesh(new THREE.CylinderGeometry(0.83,0.86,0.36,64), new THREE.MeshStandardMaterial({ color:'#f3c06e', roughness:.6 })); lower.castShadow=true; lower.position.y=0.05; cake.add(lower);
    const stripe1 = new THREE.Mesh(new THREE.CylinderGeometry(0.84,0.84,0.06,64), new THREE.MeshStandardMaterial({ color:'#fff7f5', roughness:.35 })); stripe1.position.y=0.19; cake.add(stripe1);
    const stripe2 = new THREE.Mesh(new THREE.CylinderGeometry(0.845,0.845,0.04,64), new THREE.MeshStandardMaterial({ color:'#ff4d5a', roughness:.35 })); stripe2.position.y=0.13; cake.add(stripe2);
    const topLayer = new THREE.Mesh(new THREE.CylinderGeometry(0.78,0.78,0.22,64), new THREE.MeshStandardMaterial({ color:'#ffe3f1', roughness:.45 })); topLayer.position.y=0.38; topLayer.castShadow=true; cake.add(topLayer);
    for(let i=0;i<12;i++){ const a=i/12*Math.PI*2,r=0.72; const ros=new THREE.Mesh(new THREE.TorusGeometry(0.07,0.03,12,24), new THREE.MeshStandardMaterial({ color:'#fff7f5', roughness:.25 })); ros.position.set(Math.cos(a)*r,0.47,Math.sin(a)*r); ros.castShadow=true; cake.add(ros); }
    const drizzle = new THREE.Mesh(new THREE.TorusGeometry(0.77,0.09,24,120), new THREE.MeshPhysicalMaterial({ color:'#ff4d5a', roughness:.22, clearcoat:.4 })); drizzle.position.y=0.28; drizzle.castShadow=true; cake.add(drizzle);
    [[-0.25,0.55,0.2],[0.2,0.55,-0.12]].forEach(p=>{ const m=new THREE.Mesh(new THREE.SphereGeometry(0.1,22,22), new THREE.MeshStandardMaterial({ color:'#ff4d5a', roughness:.4 })); m.position.set(...p); m.castShadow=true; cake.add(m); });
    [[-0.2,0.52,0.18,0.28],[0.16,0.52,-0.12,-0.18]].forEach(p=>{ const s=new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,0.6,16), new THREE.MeshStandardMaterial({ color:'#8b5a2b', roughness:.75 })); s.position.set(p[0],p[1],p[2]); s.rotation.x=p[3]; s.castShadow=true; cake.add(s); });

    // candle
    const flameTex = ()=>texFromCanvas((g,w,h)=>{ const r=w/2, grd=g.createRadialGradient(r,r,4,r,r,r); grd.addColorStop(0,'rgba(255,240,180,1)'); grd.addColorStop(.35,'rgba(255,170,40,.95)'); grd.addColorStop(1,'rgba(255,140,40,0)'); g.fillStyle=grd; g.beginPath(); g.arc(r,r,r,0,Math.PI*2); g.fill(); },128,128);
    const candle = new THREE.Group(); candle.position.set(0,0.95,0); cake.add(candle);
    const cBody = new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,0.9,32), new THREE.MeshStandardMaterial({ color:'#fff4d6', roughness:.4, metalness:.05 })); cBody.castShadow=true; candle.add(cBody);
    const wick  = new THREE.Mesh(new THREE.CylinderGeometry(0.006,0.006,0.08,8), new THREE.MeshStandardMaterial({ color:'#222'})); wick.position.y=0.48; candle.add(wick);
    const flame = new THREE.Sprite(new THREE.SpriteMaterial({ map:flameTex(), depthWrite:false, transparent:true, blending:THREE.AdditiveBlending })); flame.position.y=0.56; candle.add(flame);
    const sparkGeo=new THREE.BufferGeometry(), N=140, A=new Float32Array(N*3);
    for(let i=0;i<N;i++){A[i*3]=(Math.random()-.5)*.05;A[i*3+1]=Math.random()*.12-.03;A[i*3+2]=(Math.random()-.5)*.05;}
    sparkGeo.setAttribute('position', new THREE.BufferAttribute(A,3));
    const sparks=new THREE.Points(sparkGeo,new THREE.PointsMaterial({size:0.02,color:'#ffcc66',transparent:true,depthWrite:false,blending:THREE.AdditiveBlending})); sparks.position.y=0.6; candle.add(sparks);
    let blown=false; const toggleBlow=()=>{blown=!blown; flame.visible=!blown;};

    // knife
    const knife=new THREE.Group(); knife.position.set(1.4,0.82,0.2); knife.rotation.y=-Math.PI/12; scene.add(knife);
    knife.add(new THREE.Mesh(new THREE.BoxGeometry(0.9,0.04,0.06), new THREE.MeshPhysicalMaterial({ color:'#ccc', metalness:1, roughness:.2, clearcoat:.6 })));
    const tip=new THREE.Mesh(new THREE.ConeGeometry(0.06,0.14,12), new THREE.MeshPhysicalMaterial({ color:'#d0d0d0', metalness:1, roughness:.2 })); tip.position.x=0.45; knife.add(tip);
    const handle=new THREE.Mesh(new THREE.BoxGeometry(0.28,0.08,0.1), new THREE.MeshStandardMaterial({ color:'#4b2e1e', roughness:.6 })); handle.position.x=-0.55; knife.add(handle);
    let cut=false; const toggleCut=()=>{ cut=!cut; };

    // picking
    const ray=new THREE.Raycaster(), mouse=new THREE.Vector2();
    function pick(e){
      const r=renderer.domElement.getBoundingClientRect();
      mouse.x=((e.clientX-r.left)/r.width)*2-1; mouse.y=-((e.clientY-r.top)/r.height)*2+1;
      ray.setFromCamera(mouse,camera);
      const cakeHits=ray.intersectObjects([lower,topLayer],true); if(cakeHits.length){ toggleCut(); return; }
      const cardHits=ray.intersectObjects([cardBase,cardFront],true); if(cardHits.length){ toggleCard(); return; }
    }
    renderer.domElement.addEventListener('pointerdown', pick);

    // card
    function cardTex(){ return texFromCanvas((g,w,h)=>{ g.fillStyle='#fff'; g.strokeStyle='#e9e6e0'; g.lineWidth=8; g.fillRect(0,0,w,h); g.strokeRect(4,4,w-8,h-8);
      g.fillStyle='#000'; g.font='700 48px system-ui'; g.fillText('HAPPY BIRTHDAY HUNNY',44,100);
      g.font='22px system-ui'; const txt="This is just me being a part of your non-lowkey birthday this year hehe. Thank you for being my exploring, bakchodi, music, deep talks and random walks partner. Seeing you grow over this last one year has been truly gratifying. Can't wait to see all the success, happiness and masti this next year brings for. I miss you <3";
      const lines=(s,max,ctx)=>{const wds=s.split(' '),out=[];let cur=''; for(const w of wds){const t=cur?cur+' '+w:w; if(ctx.measureText(t).width>max){out.push(cur);cur=w;} else cur=t;} if(cur)out.push(cur); return out;};
      let y=150; for(const line of lines(txt,w-88,g)){ g.fillText(line,44,y); y+=34; }
    },1024,640);}
    const card=new THREE.Group(); card.position.set(1.6,0,1.0); card.rotation.y=-Math.PI/8; scene.add(card);
    const cardBase=new THREE.Mesh(new THREE.PlaneGeometry(1.7,1.1), new THREE.MeshStandardMaterial({ color:'#f3efe6' })); cardBase.rotation.x=-Math.PI/2; card.add(cardBase);
    const cardFront=new THREE.Mesh(new THREE.PlaneGeometry(1.7,1.1), new THREE.MeshBasicMaterial({ map:cardTex(), toneMapped:false })); cardFront.position.set(0,0.001,0); card.add(cardFront);
    let cardOpen=true; const toggleCard=()=>{ cardOpen=!cardOpen; };

    // instruction line
    const instrT = texFromCanvas((g,w,h)=>{ g.fillStyle='rgba(255,255,255,.95)'; g.font='700 108px system-ui'; g.textAlign='center'; g.textBaseline='middle'; g.shadowColor='rgba(0,0,0,.6)'; g.shadowBlur=12; g.shadowOffsetY=4; g.fillText('Drag • Scroll • Click cake • SPACE blow • Click card', w/2, h/2); }, 2000, 220);
    const instr = new THREE.Mesh(new THREE.PlaneGeometry(6.2,0.7), new THREE.MeshBasicMaterial({ map:instrT, transparent:true, toneMapped:false }));
    instr.rotation.x=-Math.PI/2; instr.position.set(0,0.101,4.2); scene.add(instr);

    addEventListener('keydown',e=>{ if(e.code==='Space') toggleBlow(); });

    // --- Audio wiring (safe) ---
    let player=null, muted=true, playing=false;
    function safeYT(){ try{ initYT(); }catch(e){ console.error(e); } }
    function initYT(){
      if(player&&player.playVideo){ player.playVideo(); playing=true; return; }
      if(window.YT&&window.YT.Player){ makePlayer(); return; }
      const s=document.createElement('script'); s.src='https://www.youtube.com/iframe_api'; s.async=true; s.onload=()=>{ if(window.YT&&window.YT.Player) makePlayer(); }; document.head.appendChild(s);
    }
    function makePlayer(){
      player = new YT.Player('yt',{ videoId:YT_ID, height:'0', width:'0',
        playerVars:{autoplay:1,mute:1,loop:1,playlist:YT_ID,start:YT_START,controls:0,disablekb:1,playsinline:1},
        events:{ onReady:(e)=>{e.target.playVideo(); playing=true;},
                 onStateChange:(e)=>{ if(e.data===YT.PlayerState.ENDED){ try{e.target.seekTo(YT_START,true);e.target.playVideo();}catch{} } } }
      });
    }
    document.getElementById('mute')?.addEventListener('click',()=>{
      if(!player){ muted=!muted; document.getElementById('mute').textContent = muted?'Unmute':'Mute'; return; }
      muted=!muted; muted?player.mute():player.unMute(); document.getElementById('mute').textContent = muted?'Unmute':'Mute';
    });
    document.getElementById('play')?.addEventListener('click',()=>{
      if(!player) return; if(playing) player.pauseVideo(); else player.playVideo(); playing=!playing;
      document.getElementById('play').textContent = playing?'Pause':'Play';
    });

    // --- respond to Start ---
    function onStart(){
      // zoom-out 10%
      const from=camera.position.clone(), to=from.clone().multiplyScalar(1.1), T=500, t0=performance.now();
      (function step(now){ const k=Math.min(1,(now-t0)/T); camera.position.lerpVectors(from,to,k); if(k<1) requestAnimationFrame(step); })();
      safeYT();
    }
    document.addEventListener('app-start', onStart);
    if (window.__started) onStart(); // if Start was clicked before module evaluated

    // --- loop ---
    renderer.setAnimationLoop((t)=>{
      controls.update();
      if(!blown){ const s=0.12+Math.sin(t*0.012)*0.015; flame.scale.set(s,s*1.6,1); flame.position.x=Math.sin(t*0.006)*0.01; }
      const pos=sparks.geometry.attributes.position;
      for(let i=0;i<pos.count;i++){ let y=pos.getY(i)+0.01+Math.random()*0.004; if(y>0.18) y=-0.03-Math.random()*0.03; pos.setY(i,y); } pos.needsUpdate=true;
      knife.rotation.y += ((cut?-Math.PI/3:-Math.PI/12) - knife.rotation.y)*0.08;
      knife.position.x   += ((cut?0.9:1.4) - knife.position.x)*0.08;
      card.position.z    += ((cardOpen?0.25:0.0) - card.position.z)*0.12;
      const sTarget=cardOpen?1.2:0.9; card.scale.x += (sTarget-card.scale.x)*0.12; card.scale.y=card.scale.z=card.scale.x;
      cardFront.rotation.x += ((cardOpen?0:Math.PI/2) - cardFront.rotation.x)*0.12;
      renderer.render(scene,camera);
    });
  </script>
</body>
</html>
