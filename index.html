<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>3D Birthday • Three.js</title>
<style>
  html,body{height:100%;margin:0;background:#0b0b0b}
  #app{position:fixed;inset:0;z-index:0}
  canvas{display:block}
  .hud{position:fixed;top:14px;right:14px;display:flex;gap:10px;z-index:12}
  .btn{padding:12px 16px;background:rgba(255,255,255,.18);color:#fff;border:0;border-radius:12px;cursor:pointer;font:600 15px system-ui;backdrop-filter:blur(6px)}
  .start{position:fixed;inset:0;display:grid;place-items:center;z-index:9999;background:rgba(0,0,0,.72);color:#eee}
  .panel{background:#111;border:1px solid #333;padding:22px;border-radius:14px;width:420px;text-align:center}
  .start .btn{background:#3a86ff}
</style>
</head>
<body>
  <div id="app"></div>

  <div class="hud">
    <button id="mute" class="btn">Unmute</button>
    <button id="play" class="btn">Play</button>
  </div>

  <div id="gate" class="start">
    <div class="panel">
      <div style="font-size:22px;margin-bottom:8px">Ready?</div>
      <div style="font-size:14px;opacity:.85;margin-bottom:16px">Tap Start to begin (audio optional).</div>
      <button id="start" class="btn">Start</button>
    </div>
  </div>

  <div id="yt" style="position:fixed;width:0;height:0;overflow:hidden"></div>

  <!-- Boot (non-module) -->
  <script>
    (function(){
      const gate=document.getElementById('gate');
      function start(){
        if(window.__started) return;
        window.__started=true;
        try{ gate.remove(); }catch{}
        document.dispatchEvent(new Event('app-start'));
      }
      ['click','pointerdown','touchstart'].forEach(ev=>{
        document.getElementById('start').addEventListener(ev,start,{passive:true});
      });
      // surface runtime errors on page
      window.addEventListener('error',e=>{
        const d=document.createElement('div');
        d.style.cssText='position:fixed;bottom:10px;left:10px;background:#300;color:#fff;padding:10px;border-radius:8px;z-index:99999;font:12px monospace;max-width:90vw';
        d.textContent='JS error: '+(e.message||e.error||'unknown');
        document.body.appendChild(d);
      });
    })();
  </script>

  <!-- Main module (esm.sh removes import-map headaches) -->
  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.161.0';
    import { OrbitControls } from 'https://esm.sh/three@0.161.0/examples/jsm/controls/OrbitControls.js';
    import { RoundedBoxGeometry } from 'https://esm.sh/three@0.161.0/examples/jsm/geometries/RoundedBoxGeometry.js';

    // ---- Content ----
    const SKYLINE='https://upload.wikimedia.org/wikipedia/commons/d/d1/Toronto_Skyline_at_night_-b.jpg';
    const PHOTOS=['p1.jpg','p2.jpg','p3.jpg','p4.jpg']; // keep these next to index.html
    const YT_ID='B-2BCSxnyHA', YT_START=84;

    // ---- Renderer / Scene / Camera ----
    const app=document.getElementById('app');
    const renderer=new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    renderer.setSize(innerWidth,innerHeight);
    renderer.shadowMap.enabled=true;
    renderer.shadowMap.type=THREE.PCFSoftShadowMap;
    renderer.outputColorSpace=THREE.SRGBColorSpace;
    renderer.toneMapping=THREE.ACESFilmicToneMapping;
    app.appendChild(renderer.domElement);

    const scene=new THREE.Scene();
    const camera=new THREE.PerspectiveCamera(45,innerWidth/innerHeight,0.1,200);
    camera.position.set(3.8,2.6,5.4);

    const controls=new OrbitControls(camera,renderer.domElement);
    controls.enableDamping=true; controls.dampingFactor=.06;
    controls.rotateSpeed=.9; controls.zoomSpeed=.9; controls.panSpeed=.8;
    controls.target.set(0,.45,0);

    addEventListener('resize',()=>{
      camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(innerWidth,innerHeight);
    });

    // ---- Lights ----
    scene.add(new THREE.AmbientLight(0xffffff,.62));
    const spot=new THREE.SpotLight(0xffffff,1.35,0,.6,.7,1.2);
    spot.position.set(4,6,2); spot.castShadow=true; scene.add(spot);

    // ---- helpers ----
    const texFromCanvas=(draw,w=1024,h=1024)=>{
      const c=document.createElement('canvas'); c.width=w; c.height=h; const g=c.getContext('2d');
      draw(g,w,h); const t=new THREE.CanvasTexture(c); t.colorSpace=THREE.SRGBColorSpace; t.anisotropy=16; return t;
    };
    const loadTex=url=>new Promise(res=>{
      const t=new THREE.Texture(), img=new Image(); img.crossOrigin='anonymous';
      img.onload=()=>{ t.image=img; t.needsUpdate=true; t.colorSpace=THREE.SRGBColorSpace; t.anisotropy=16; res(t); };
      img.onerror=()=>res(texFromCanvas(g=>{ g.fillStyle='#bbb'; g.fillRect(0,0,1024,1024); }));
      img.src=url;
    });

    // ---- Table + cloth ----
    const wood=texFromCanvas((g,w,h)=>{
      g.fillStyle='#6e4a2e'; g.fillRect(0,0,w,h);
      for(let y=0;y<h;y++){ const a=30+Math.sin(y*.015)*18+Math.sin(y*.06)*6; g.fillStyle=`rgba(255,255,255,${(a/255)*.08})`; g.fillRect(0,y,w,1); }
    });
    wood.wrapS=wood.wrapT=THREE.RepeatWrapping; wood.repeat.set(2.2,2.2);

    const cloth=texFromCanvas((g,w,h)=>{
      const A='#e7defa', B='#1c1c22', n=12, s=w/n;
      for(let y=0;y<n;y++) for(let x=0;x<n;x++){ g.fillStyle=((x+y)%2)?B:A; g.fillRect(x*s,y*s,s,s); }
    });
    cloth.wrapS=cloth.wrapT=THREE.RepeatWrapping; cloth.repeat.set(2.6,2.15);

    const tableTop=new THREE.Mesh(new THREE.BoxGeometry(14,.18,10),
      new THREE.MeshPhysicalMaterial({map:wood,metalness:.05,roughness:.38,clearcoat:.65,clearcoatRoughness:.25}));
    tableTop.castShadow=tableTop.receiveShadow=true; scene.add(tableTop);

    const clothMesh=new THREE.Mesh(new THREE.PlaneGeometry(13.6,9.8),
      new THREE.MeshStandardMaterial({map:cloth}));
    clothMesh.rotation.x=-Math.PI/2; clothMesh.position.y=.1; clothMesh.receiveShadow=true; scene.add(clothMesh);

    // ---- 3D L-shaped skyline (no floor gap) ----
    (async()=>{
      const sky=await loadTex(SKYLINE);
      const m=new THREE.MeshBasicMaterial({map:sky,toneMapped:false});
      const W=28,H=W*9/16, y=.1+H/2, d=5.0;
      const back=new THREE.Mesh(new THREE.BoxGeometry(W,H,.1),m); back.position.set(0,y,-d-.1); scene.add(back);
      const side=new THREE.Mesh(new THREE.BoxGeometry(W,H,.1),m); side.position.set(7.1,y,0); side.rotation.y=-Math.PI/2; scene.add(side);
      const r=7.1;
      const corner=new THREE.Mesh(
        new THREE.CylinderGeometry(r,r,H,80,1,false,Math.PI,Math.PI/2),
        new THREE.MeshBasicMaterial({map:sky,side:THREE.DoubleSide,toneMapped:false})
      ); corner.position.set(r,y,-r); corner.rotation.y=Math.PI/2; scene.add(corner);
    })();

    // ---- Frames ----
    async function addFrame(url,pos,rot){
      const group=new THREE.Group(); group.position.set(...pos); group.rotation.set(...rot);
      const W=1.5,H=1.05;

      const rim=new THREE.Mesh(new RoundedBoxGeometry(W+.16,H+.16,.08,6,.06),
        new THREE.MeshStandardMaterial({color:'#b48a64',metalness:.15,roughness:.6}));
      rim.position.y=H/2; rim.castShadow=true; group.add(rim);

      const mat=new THREE.Mesh(new THREE.BoxGeometry(W+.04,H+.04,.02),
        new THREE.MeshStandardMaterial({color:'#f3efe8'}));
      mat.position.y=H/2; mat.position.z=.03; group.add(mat);

      const tex=await loadTex(url);
      const ph=new THREE.Mesh(new THREE.PlaneGeometry(W,H),
        new THREE.MeshBasicMaterial({map:tex,toneMapped:false}));
      ph.position.y=H/2; ph.position.z=.05; group.add(ph);

      const stand=new THREE.Mesh(new THREE.CylinderGeometry(0,.18,.25,4),
        new THREE.MeshStandardMaterial({color:'#6e5a46',roughness:.95}));
      stand.rotation.x=Math.PI/2; stand.position.set(0,.02,-.08); group.add(stand);

      scene.add(group);
    }
    addFrame(PHOTOS[0],[-2.2,.09,.1],[0,THREE.MathUtils.degToRad(20),0]);
    addFrame(PHOTOS[1],[-1.1,.09,-1.35],[0,THREE.MathUtils.degToRad(42),0]);
    addFrame(PHOTOS[2],[1.25,.09,-1.45],[0,THREE.MathUtils.degToRad(-38),0]);
    addFrame(PHOTOS[3],[2.35,.09,.15],[0,THREE.MathUtils.degToRad(-16),0]);

    // ---- Candle flame texture ----
    const flameTex=()=>texFromCanvas((g,w,h)=>{
      const r=w/2, grd=g.createRadialGradient(r,r,4,r,r,r);
      grd.addColorStop(0,'rgba(255,240,180,1)');
      grd.addColorStop(.35,'rgba(255,170,40,.95)');
      grd.addColorStop(1,'rgba(255,140,40,0)');
      g.fillStyle=grd; g.beginPath(); g.arc(r,r,r,0,Math.PI*2); g.fill();
    },128,128);

    // ---- Cake (colorful) ----
    const cake=new THREE.Group(); cake.position.set(0,0.5,0); scene.add(cake);

    const plate=new THREE.Mesh(new THREE.CircleGeometry(1.25,64),
      new THREE.MeshStandardMaterial({color:'#f7f7f7',roughness:.35,metalness:.05}));
    plate.rotation.x=-Math.PI/2; plate.position.y=-.505; plate.receiveShadow=true; cake.add(plate);

    for(let i=0;i<24;i++){
      const a=i/24*Math.PI*2, r=.95;
      const pearl=new THREE.Mesh(new THREE.SphereGeometry(.05,16,16),
        new THREE.MeshStandardMaterial({color:'#fff7f5',roughness:.2}));
      pearl.position.set(Math.cos(a)*r,.18,Math.sin(a)*r); pearl.castShadow=true; cake.add(pearl);
    }

    const lower=new THREE.Mesh(new THREE.CylinderGeometry(.83,.86,.36,64),
      new THREE.MeshStandardMaterial({color:'#f3c06e',roughness:.6}));
    lower.castShadow=true; lower.position.y=.05; cake.add(lower);

    const stripe1=new THREE.Mesh(new THREE.CylinderGeometry(.84,.84,.06,64),
      new THREE.MeshStandardMaterial({color:'#fff7f5',roughness:.35}));
    stripe1.position.y=.19; cake.add(stripe1);

    const stripe2=new THREE.Mesh(new THREE.CylinderGeometry(.845,.845,.04,64),
      new THREE.MeshStandardMaterial({color:'#ff4d5a',roughness:.35}));
    stripe2.position.y=.13; cake.add(stripe2);

    const topLayer=new THREE.Mesh(new THREE.CylinderGeometry(.78,.78,.22,64),
      new THREE.MeshStandardMaterial({color:'#ffe3f1',roughness:.45}));
    topLayer.position.y=.38; topLayer.castShadow=true; cake.add(topLayer);

    for(let i=0;i<12;i++){
      const a=i/12*Math.PI*2, r=.72;
      const ros=new THREE.Mesh(new THREE.TorusGeometry(.07,.03,12,24),
        new THREE.MeshStandardMaterial({color:'#fff7f5',roughness:.25}));
      ros.position.set(Math.cos(a)*r,.47,Math.sin(a)*r); ros.castShadow=true; cake.add(ros);
    }

    const drizzle=new THREE.Mesh(new THREE.TorusGeometry(.77,.09,24,120),
      new THREE.MeshPhysicalMaterial({color:'#ff4d5a',roughness:.22,clearcoat:.4}));
    drizzle.position.y=.28; drizzle.castShadow=true; cake.add(drizzle);

    [[-.25,.55,.2],[.2,.55,-.12]].forEach(p=>{
      const berry=new THREE.Mesh(new THREE.SphereGeometry(.1,22,22),
        new THREE.MeshStandardMaterial({color:'#ff4d5a',roughness:.4}));
      berry.position.set(...p); berry.castShadow=true; cake.add(berry);
    });

    [[-.2,.52,.18,.28],[.16,.52,-.12,-.18]].forEach(p=>{
      const stick=new THREE.Mesh(new THREE.CylinderGeometry(.03,.03,.6,16),
        new THREE.MeshStandardMaterial({color:'#8b5a2b',roughness:.75}));
      stick.position.set(p[0],p[1],p[2]); stick.rotation.x=p[3]; stick.castShadow=true; cake.add(stick);
    });

    // candle
    const candle=new THREE.Group(); candle.position.set(0,.95,0); cake.add(candle);
    const cBody=new THREE.Mesh(new THREE.CylinderGeometry(.06,.06,.9,32),
      new THREE.MeshStandardMaterial({color:'#fff4d6',roughness:.4,metalness:.05}));
    cBody.castShadow=true; candle.add(cBody);
    const wick=new THREE.Mesh(new THREE.CylinderGeometry(.006,.006,.08,8),
      new THREE.MeshStandardMaterial({color:'#222'})); wick.position.y=.48; candle.add(wick);
    const flame=new THREE.Sprite(new THREE.SpriteMaterial({map:flameTex(),depthWrite:false,transparent:true,blending:THREE.AdditiveBlending}));
    flame.position.y=.56; candle.add(flame);

    const sparkGeo=new THREE.BufferGeometry(), N=140, A=new Float32Array(N*3);
    for(let i=0;i<N;i++){A[i*3]=(Math.random()-.5)*.05;A[i*3+1]=Math.random()*.12-.03;A[i*3+2]=(Math.random()-.5)*.05;}
    sparkGeo.setAttribute('position',new THREE.BufferAttribute(A,3));
    const sparks=new THREE.Points(sparkGeo,new THREE.PointsMaterial({size:.02,color:'#ffcc66',transparent:true,depthWrite:false,blending:THREE.AdditiveBlending}));
    sparks.position.y=.6; candle.add(sparks);
    let blown=false; const toggleBlow=()=>{ blown=!blown; flame.visible=!blown; };
    addEventListener('keydown',e=>{ if(e.code==='Space') toggleBlow(); });

    // knife
    const knife=new THREE.Group(); knife.position.set(1.4,.82,.2); knife.rotation.y=-Math.PI/12; scene.add(knife);
    knife.add(new THREE.Mesh(new THREE.BoxGeometry(.9,.04,.06), new THREE.MeshPhysicalMaterial({color:'#ccc',metalness:1,roughness:.2,clearcoat:.6})));
    const tip=new THREE.Mesh(new THREE.ConeGeometry(.06,.14,12), new THREE.MeshPhysicalMaterial({color:'#d0d0d0',metalness:1,roughness:.2})); tip.position.x=.45; knife.add(tip);
    const handle=new THREE.Mesh(new THREE.BoxGeometry(.28,.08,.1), new THREE.MeshStandardMaterial({color:'#4b2e1e',roughness:.6})); handle.position.x=-.55; knife.add(handle);
    let cut=false; const toggleCut=()=>{ cut=!cut; };

    // card
    function cardTex(){ return texFromCanvas((g,w,h)=>{ g.fillStyle='#fff'; g.strokeStyle='#e9e6e0'; g.lineWidth=8; g.fillRect(0,0,w,h); g.strokeRect(4,4,w-8,h-8);
      g.fillStyle='#000'; g.font='700 48px system-ui'; g.fillText('HAPPY BIRTHDAY HUNNY',44,100);
      g.font='22px system-ui'; const txt="This is just me being a part of your non-lowkey birthday this year hehe. Thank you for being my exploring, bakchodi, music, deep talks and random walks partner. Seeing you grow over this last one year has been truly gratifying. Can't wait to see all the success, happiness and masti this next year brings for. I miss you <3";
      const lines=(s,max,ctx)=>{const a=s.split(' '),o=[];let c='';for(const w of a){const t=c?c+' '+w:w;if(ctx.measureText(t).width>max){o.push(c);c=w;}else c=t;} if(c) o.push(c); return o;};
      let y=150; for(const ln of lines(txt,w-88,g)){ g.fillText(ln,44,y); y+=34; }
    },1024,640);}
    const card=new THREE.Group(); card.position.set(1.6,0,1.0); card.rotation.y=-Math.PI/8; scene.add(card);
    const cardBase=new THREE.Mesh(new THREE.PlaneGeometry(1.7,1.1), new THREE.MeshStandardMaterial({color:'#f3efe6'}));
    cardBase.rotation.x=-Math.PI/2; card.add(cardBase);
    const cardFront=new THREE.Mesh(new THREE.PlaneGeometry(1.7,1.1), new THREE.MeshBasicMaterial({map:cardTex(),toneMapped:false}));
    cardFront.position.set(0,.001,0); card.add(cardFront);
    let cardOpen=true; const toggleCard=()=>{ cardOpen=!cardOpen; };

    // instruction strip
    const instrTex=texFromCanvas((g,w,h)=>{ g.fillStyle='rgba(255,255,255,.95)'; g.font='700 108px system-ui';
      g.textAlign='center'; g.textBaseline='middle'; g.shadowColor='rgba(0,0,0,.6)'; g.shadowBlur=12; g.shadowOffsetY=4;
      g.fillText('Drag • Scroll • Click cake • SPACE blow • Click card', w/2, h/2);
    }, 2200, 220);
    const instr=new THREE.Mesh(new THREE.PlaneGeometry(6.4,.7), new THREE.MeshBasicMaterial({map:instrTex,transparent:true,toneMapped:false}));
    instr.rotation.x=-Math.PI/2; instr.position.set(0,.101,4.2); scene.add(instr);

    // picking
    const ray=new THREE.Raycaster(), mouse=new THREE.Vector2();
    function pick(e){
      const r=renderer.domElement.getBoundingClientRect();
      mouse.x=((e.clientX-r.left)/r.width)*2-1; mouse.y=-((e.clientY-r.top)/r.height)*2+1;
      ray.setFromCamera(mouse,camera);
      const cakeHits=ray.intersectObjects([lower,topLayer,drizzle],true); if(cakeHits.length){ toggleCut(); return; }
      const cardHits=ray.intersectObjects([cardBase,cardFront],true); if(cardHits.length){ toggleCard(); return; }
    }
    renderer.domElement.addEventListener('pointerdown', pick);

    // audio (YouTube)
    let player=null, muted=true, playing=false;
    function safeYT(){ try{ initYT(); }catch(e){ console.error(e); } }
    function initYT(){
      if(player && player.playVideo){ player.playVideo(); playing=true; return; }
      if(window.YT && window.YT.Player){ makePlayer(); return; }
      const s=document.createElement('script'); s.src='https://www.youtube.com/iframe_api'; s.async=true;
      s.onload=()=>{ if(window.YT && window.YT.Player) makePlayer(); };
      document.head.appendChild(s);
    }
    function makePlayer(){
      player=new YT.Player('yt',{
        videoId:YT_ID,width:'0',height:'0',
        playerVars:{autoplay:1,mute:1,loop:1,playlist:YT_ID,start:YT_START,controls:0,disablekb:1,playsinline:1},
        events:{ onReady:(e)=>{ e.target.playVideo(); playing=true; },
                 onStateChange:(e)=>{ if(e.data===YT.PlayerState.ENDED){ try{ e.target.seekTo(YT_START,true); e.target.playVideo(); }catch{} } } }
      });
    }
    document.getElementById('mute').addEventListener('click',()=>{
      if(!player){ muted=!muted; document.getElementById('mute').textContent=muted?'Unmute':'Mute'; return; }
      muted=!muted; muted?player.mute():player.unMute();
      document.getElementById('mute').textContent=muted?'Unmute':'Mute';
    });
    document.getElementById('play').addEventListener('click',()=>{
      if(!player) return;
      if(playing) player.pauseVideo(); else player.playVideo();
      playing=!playing; document.getElementById('play').textContent=playing?'Pause':'Play';
    });

    // start
    function onStart(){
      const from=camera.position.clone(), to=from.clone().multiplyScalar(1.1), T=500, t0=performance.now();
      (function step(now){ const k=Math.min(1,(now-t0)/T); camera.position.lerpVectors(from,to,k); if(k<1) requestAnimationFrame(step); })();
      safeYT();
    }
    document.addEventListener('app-start', onStart);
    if(window.__started) onStart();

    // render loop
    let frames=0; // debug: if nothing renders, show message
    renderer.setAnimationLoop((t)=>{
      frames++;
      controls.update();

      if(!blown){
        const s=.12+Math.sin(t*.012)*.015;
        flame.scale.set(s,s*1.6,1);
        flame.position.x=Math.sin(t*.006)*.01;
      }
      const pos=sparks.geometry.attributes.position;
      for(let i=0;i<pos.count;i++){
        let y=pos.getY(i)+.01+Math.random()*.004;
        if(y>.18) y=-.03-Math.random()*.03;
        pos.setY(i,y);
      }
      pos.needsUpdate=true;

      knife.rotation.y += ((cut?-Math.PI/3:-Math.PI/12)-knife.rotation.y)*.08;
      knife.position.x   += ((cut?.9:1.4) - knife.position.x)*.08;

      card.position.z    += ((cardOpen?.25:0) - card.position.z)*.12;
      const sTarget=cardOpen?1.2:.9; card.scale.x += (sTarget-card.scale.x)*.12; card.scale.y=card.scale.z=card.scale.x;
      cardFront.rotation.x += ((cardOpen?0:Math.PI/2)-cardFront.rotation.x)*.12;

      renderer.render(scene,camera);
    });
    setTimeout(()=>{
      if(frames<5){
        const d=document.createElement('div');
        d.style.cssText='position:fixed;bottom:10px;left:10px;background:#632;color:#fff;padding:10px;border-radius:8px;z-index:99999;font:12px monospace;max-width:90vw';
        d.textContent='No frames rendered. If you see this on Vercel, your HTML wasn’t deployed exactly or your browser blocked modules. Replace index.html with THIS file and clear cache.';
        document.body.appendChild(d);
      }
    }, 1500);
  </script>
</body>
</html>
